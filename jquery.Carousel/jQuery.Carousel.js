// Generated by CoffeeScript 1.4.0
/*
 * jQuery.carousel
 * A simple jQuery plugin for content carousels
 * Author: Ben Saufley
 *   for Millennium Partners Sports Club Management, LLC
 *   http://sportsclubla.com
 * Based on jQuery plugin boilerplate by Jonathan Nicol @f6design
*/

(function($) {
  var Plugin, pluginName;
  pluginName = 'carousel';
  Plugin = function(element, options) {
    var $c, $el, $next, $prev, destroy, el, fill, hook, hover, hoverUpdate, init, looper, moveTo, next, onFirst, onLast, option, prev, queued, startAuto, stopAuto;
    el = element;
    $el = $(element);
    $c = $el.children().first();
    $next = $prev = null;
    looper = null;
    hover = false;
    queued = false;
    options = $.extend({}, $.fn[pluginName].defaults, options);
    init = function() {
      var $half, cwidth, width;
      $el.css({
        'overflow-x': 'hidden',
        'position': 'relative'
      });
      $c.css({
        'position': 'absolute',
        'left': '50%'
      });
      if (options.nojs_class) {
        $c.children().removeClass(options.nojs_class);
      }
      if (options.focused) {
        options.focused = $(options.focused);
      } else {
        options.focused = $c.children().first();
      }
      if (options.infinite) {
        if ($c.children().first()[0] !== options.focused[0]) {
          $c.children().first().add($c.children().first().nextUntil($(options.focused))).appendTo($c);
        }
        fill();
        width = 0;
        $half = null;
        console.log($c.outerWidth(true));
        cwidth = 0;
        $c.children().each(function() {
          return cwidth += $(this).outerWidth(true);
        });
        options.focused.nextAll().each(function() {
          width += $(this).outerWidth(true);
          $half = $(this);
          if (width >= cwidth / 2) {
            return false;
          }
        });
        $half.add($half.nextAll()).prependTo($c);
      }
      return setTimeout(function() {
        moveTo(options.focused, 0, true);
        $next = $('<div />', {
          'class': options.next_class,
          'text': 'NEXT'
        });
        $prev = $('<div />', {
          'class': options.prev_class,
          'text': 'PREVIOUS'
        });
        $next.appendTo($el).on('click tap', next);
        $prev.appendTo($el).on('click tap', prev);
        if (onLast() && !options.infinite && !options.typewriter) {
          $next.hide();
        }
        if (onFirst() && !options.infinite && !options.typewriter) {
          $prev.hide();
        }
        if (options.auto) {
          startAuto();
        }
        return hook('onInit');
      }, 5000);
    };
    destroy = function() {
      return $el.each(function() {
        $el = $(this);
        $el.css({
          'overflow-x': '',
          'position': ''
        });
        $c.css({
          'position': '',
          'left': '',
          'margin-left': ''
        });
        $next.add($prev).remove();
        stopAuto();
        if (options.nojs_class) {
          $c.addClass(options.nojs_class);
        }
        if (options.focus_class) {
          $c.find("." + options.focus_class).removeClass(options.focus_class);
        }
        hook('onDestroy');
        return $el.removeData("plugin_" + pluginName);
      });
    };
    moveTo = function(to, speed, init) {
      var $moving, e, fromEnd, i, ind, movewidth, width, _i, _len;
      if (speed == null) {
        speed = options.speed;
      }
      if (!queued) {
        queued = true;
        if (options.focused[0] !== to[0] || init) {
          if (!init) {
            hook('onStart');
          }
          if (options.infinite && !init) {
            ind = options.focused.index();
            movewidth = 0;
            $moving = [];
            width = 0;
            if (ind > to.index()) {
              to.add(to.nextUntil(options.focused)).each(function() {
                return movewidth += $(this).outerWidth(true);
              });
              fromEnd = Array.prototype.slice.call($c.children().last().prevUntil(options.focused).add($c.children().last())).reverse();
              for (i = _i = 0, _len = fromEnd.length; _i < _len; i = ++_i) {
                e = fromEnd[i];
                width += $(e).outerWidth(true);
                $moving[i] = $(e);
                $(e).clone().prependTo($c);
                if (width >= movewidth) {
                  break;
                }
              }
              $c.css('margin-left', "-=" + width);
            } else {
              to.add(to.prevUntil(options.focused)).each(function() {
                return movewidth += $(this).outerWidth(true);
              });
              $c.children().first().add($c.children().first().nextUntil(options.focused)).each(function(i) {
                width += $(this).outerWidth(true);
                $moving[i] = $(this);
                $(this).clone().appendTo($c);
                if (width >= movewidth) {
                  return false;
                }
              });
            }
          } else {
            if (!options.typewriter) {
              if (onLast()) {
                $next.fadeOut(speed / 2);
              } else if ($next.not(':visible')) {
                $next.fadeIn(speed / 2);
              }
              if (onFirst()) {
                $prev.fadeOut(speed / 2);
              } else if ($next.not(':visible')) {
                $prev.fadeIn(speed / 2);
              }
            }
          }
          if (options.focus_class) {
            options.focused.removeClass(options.focus_class);
          }
          return $c.animate({
            'margin-left': -(to.outerWidth(true) / 2 + to.position().left)
          }, speed, options.easing, function() {
            var _j, _len1;
            options.focused = to;
            if (options.focus_class) {
              options.focused.addClass(options.focus_class);
            }
            if (options.infinite && $moving) {
              for (i = _j = 0, _len1 = $moving.length; _j < _len1; i = ++_j) {
                e = $moving[i];
                $(e).remove();
              }
              $c.css('margin-left', -(options.focused.outerWidth(true) / 2 + options.focused.position().left));
            }
            queued = false;
            if (!init) {
              return hook('onComplete');
            }
          });
        }
      }
    };
    next = function() {
      if (options.infinite) {
        return moveTo(options.focused.next());
      } else {
        if (!onLast()) {
          return moveTo(options.focused.next());
        } else if (options.typewriter) {
          return moveTo($c.children().first());
        }
      }
    };
    prev = function() {
      if (options.infinite) {
        return moveTo(options.focused.prev());
      } else {
        if (!onFirst()) {
          return moveTo(options.focused.prev());
        } else if (options.typewriter) {
          return moveTo($c.children().last());
        }
      }
    };
    startAuto = function(speed) {
      if (speed) {
        options.auto = speed;
      }
      $el.on('mouseenter mouseleave', hoverUpdate);
      looper = setInterval(function() {
        if (!hover) {
          return next();
        }
      }, options.auto);
      return looper;
    };
    stopAuto = function() {
      if (looper) {
        $el.off('mouseenter mouseleave', hoverUpdate);
        return clearInterval(looper);
      }
    };
    hoverUpdate = function(e) {
      hover = e.type === 'mouseenter';
      return hover;
    };
    fill = function() {
      var timeout, _results;
      timeout = 0;
      _results = [];
      while ($c.outerWidth() < $el.innerWidth() && timeout < 25) {
        timeout++;
        _results.push($c.children().clone().appendTo($c));
      }
      return _results;
    };
    onLast = function() {
      return options.focused[0] === $c.children().last()[0];
    };
    onFirst = function() {
      return options.focused[0] === $c.children().first()[0];
    };
    option = function(key, val) {
      if (val) {
        return options[key] = val;
      } else {
        return options[key];
      }
    };
    hook = function(hookName) {
      if (options[hookName] !== void 0) {
        return options[hookName].call(el, options.focused);
      }
    };
    init();
    return {
      option: option,
      destroy: destroy,
      fill: fill,
      onLast: onLast,
      onFirst: onFirst,
      moveTo: moveTo,
      next: next,
      prev: prev,
      startAuto: startAuto,
      stopAuto: stopAuto
    };
  };
  $.fn[pluginName] = function(options) {
    var args, methodName, returnVal;
    if (typeof arguments[0] === 'string') {
      methodName = arguments[0];
      args = Array.prototype.slice.call(arguments, 1);
      returnVal = null;
      this.each(function() {
        if ($.data(this, "plugin_" + pluginName) && typeof $.data(this, "plugin_" + pluginName)[methodName] === 'function') {
          return (returnVal = $.data(this, "plugin_" + pluginName)[methodName].apply(this, args));
        } else {
          throw new Error("Method " + methodName + " does not exist on jQuery." + pluginName);
        }
      });
      if (returnVal !== void 0) {
        return returnVal;
      } else {
        return this;
      }
    } else if (typeof options === "object" || !options) {
      return this.each(function() {
        if (!$.data(this, 'plugin_' + pluginName)) {
          return $.data(this, "plugin_" + pluginName, new Plugin(this, options));
        }
      });
    }
  };
  return $.fn[pluginName].defaults = {
    next_class: 'next',
    prev_class: 'prev',
    nojs_class: false,
    focus_class: 'focus',
    focused: false,
    infinite: false,
    easing: 'linear',
    typewriter: false,
    speed: 300,
    hover: false,
    auto: false,
    onInit: function() {},
    onStart: function() {},
    onComplete: function() {},
    onDestroy: function() {}
  };
})(jQuery);
